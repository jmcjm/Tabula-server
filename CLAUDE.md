# Tabula Server Project Information for LLM (Claude)

This document provides key information about the Tabula Server project, aiming to facilitate LLM understanding of its structure, technologies, and code style.

## 1. General Project Description

**Project Name:** Tabula Server (Tabula-server-clean)
**Purpose:** Backend for a shopping list management application. It allows users to create lists, add products to them, manage tags, and share lists with other users with different permission levels.
**Overall Architecture:** The project is built using .NET Aspire, which simplifies orchestration and dependency management between services (currently one main `apiservice` and a database).

## 2. Key Technologies and Frameworks

*   **.NET 9:** The main application framework.
*   **ASP.NET Core:** Used for building the Web API (utilizing minimal APIs).
*   **Entity Framework Core 9 (EF Core):** ORM for interacting with the PostgreSQL database.
*   **PostgreSQL:** Relational database.
*   **.NET Aspire (9.3.1):** Used for development orchestration, configuration management (including secrets), and service integration.
*   **Docker & Docker Compose:** For containerizing the application and database. The `docker-compose.yaml` is partly managed/generated by Aspire, but there's also a `docker-compose.yaml` in `AppHost` defining services for a compiled/production-like environment.
*   **ASP.NET Core Identity:** For managing users, roles, and authentication.
*   **JWT (JSON Web Tokens):** Authentication mechanism for the API.
*   **OpenTelemetry:** Integrated via `Tabula.ServiceDefaults` for observability (logs, metrics, traces).
*   **Swagger/OpenAPI:** For API documentation, integrated in `Tabula.Infrastructure.Identity`.
*   **ErrorOr:** A library for handling operation results that can either succeed or fail, in a functional way.

## 3. Architecture and Design Patterns

*   **Project Structure (Layers):**
    *   `Tabula.AppHost`: The Aspire project, orchestrating the application.
    *   `Tabula.ServiceDefaults`: Common configurations for services (e.g., OpenTelemetry, health checks).
    *   `Tabula.Services.WebApi`: The main API project, containing endpoint definitions.
    *   `Tabula.Infrastructure.DataAccess`: Data access layer (DbContext, repositories, EF configurations, domain entities, DAO <-> Entity mappings).
    *   `Tabula.Infrastructure.Identity`: Layer responsible for authentication, authorization, and user management (IdentityDbContext, TokenService).
*   **Patterns:**
    *   **Repository Pattern:** Used in `Tabula.Infrastructure.DataAccess` to abstract database operations (e.g., `ShoppingListRepository`, `ItemRepository`).
    *   **Dependency Injection (DI):** Widely used throughout the project.
    *   **Minimal APIs:** Endpoints are defined using the Minimal APIs approach in `Tabula.Services.WebApi`.
    *   **Object Mapping:** Domain entities (`Entities`) are mapped to DAO objects (`Models` in DataAccess) and API response models (e.g., `TagResponseModel`).
    *   **Options Pattern:** Used for configuration (e.g., `JwtSettings`).
*   **Databases:** Two separate PostgreSQL databases:
    *   `TabulaDb`: Main application database (shopping lists, items, tags, shares).
    *   `IdentityDb`: Database for ASP.NET Core Identity (users, roles).

## 4. Main Functionalities

*   **Shopping List Management:** CRUD operations for shopping lists (`ShoppingListEntity`). Each list is assigned to a user (owner).
*   **Item Management:** CRUD operations for items within a specific shopping list (`Item`).
*   **Authentication and Authorization:**
    *   User registration and login.
    *   Use of roles (`admin`, `user`).
    *   Securing endpoints using JWT and `[Authorize]` attributes.
*   **Shopping List Sharing (`ShoppingListShare`):**
    *   The list owner can share it with another user.
    *   Two permission levels: `ReadOnly` and `ReadWrite`.
    *   Ability to revoke shares and change permissions.
*   **Tag Management (`Tag`):**
    *   CRUD operations for tags (each tag belongs to a user).
    *   Assigning and removing tags from shopping lists (limit of 5 tags per list).
    *   Tags have a name and a color (`TagColor` enum).
*   **Database Initialization:** `DatabaseInitializer` and `IdentityDatabaseInitializer` are responsible for migrations and seeding (e.g., creating an admin user).

## 5. Code Style and Conventions

*   **Language:** C# (utilizing newer language features, e.g., records for DTO models).
*   **Naming Conventions:**
    *   Classes, methods, properties: `PascalCase`.
    *   Local variables, method parameters: `camelCase`.
    *   Interfaces: `IPascalCase`.
*   **Asynchrony:** Extensive use of `async/await` for I/O operations.
*   **LINQ:** Used for database queries and collection operations.
*   **Formatting:** Consistent with default Visual Studio / Rider settings.
*   **Nullability:** Nullable reference types enabled (`<Nullable>enable</Nullable>`).
*   **EF Core Configuration:** Fluent API in separate configuration files (e.g., `ItemConfiguration.cs`).
*   **Endpoint Structure:** Grouping endpoints using `MapGroup` and extension methods (`MapShoppingListsEndpoint`, etc.).

## 6. Error Handling

*   **`ErrorOr` Library:** Used in the repository and service layers to return operation results that can be either a success (with a value) or a list of errors.
*   **Dedicated Error Classes:** E.g., `ShoppingListErrors`, `ItemErrors`, `TagErrors` defining specific errors (NotFound, AlreadyExists, ValidationError).
*   **Mapping to HTTP Results:** `ErrorOrExtensions.ToHttpResult` converts `ErrorOr` objects to appropriate `IResult` (e.g., `Ok`, `NotFound`, `BadRequest`, `Conflict`).
*   **Standard ProblemDetails:** Used by ASP.NET Core for unhandled exceptions or validation errors.

## 7. Database Management

*   **EF Core Migrations:** The EF Core migration system is used to manage the database schema. Migrations are applied automatically on application startup by `DatabaseInitializer` and `IdentityDatabaseInitializer`.
*   **Entity Configurations:** Detailed entity-to-table mapping configurations are located in the `Configurations` folder in `Tabula.Infrastructure.DataAccess`.
*   **Relationships:** Defined using Fluent API, including one-to-many and many-to-many relationships (e.g., ShoppingList <-> Tag).
*   **Cascade Delete:** Configured for some relationships (e.g., deleting a shopping list also deletes its items).

## 8. Security

*   **Authentication:** JWT-based, generated by `TokenService`.
*   **Authorization:** Role-based (e.g., `[Authorize(Roles = "admin,user")]`) and resource-based permission checks (e.g., whether the user owns the list or has access via a share).
*   **Secrets Management:**
    *   Aspire `AddParameter("DbPasswd", secret: true)` for key secrets.
    *   Values are loaded from an `.env` file (in Aspire development mode) or environment variables (in Docker Compose). **It's crucial that the `.env` file with actual secrets is not committed to the repository.**
    *   The admin password is required as an environment variable (`ADMIN_PASSWORD`) and its strength is validated.
*   **CORS:** A policy named `AllowFrontend` is configured, allowing access from any origin (potentially needs adjustment for a production environment).
*   **No `UseHttpsRedirection()`:** Commented out in `Program.cs` - Aspire and reverse proxy configurations (e.g., in Docker Compose) typically handle SSL termination.

## 9. Configuration and Startup (Deployment)

*   **.NET Aspire:** The primary way to run in development mode, orchestrating `apiservice` and `postgres`.
*   **Docker:** The `Dockerfile` for `Tabula.Services.WebApi` prepares the container image.
*   **Docker Compose:** The `docker-compose.yaml` in `Tabula.AppHost` defines services (`postgres`, `apiservice`) for a production-like/compiled environment, using environment variables from the `.env` file.
*   **Environment Variables:** Key for configuring database connections, admin credentials, and JWT key in a Docker environment.

## 10. Important Notes for LLM

*   **Aspire Context:** Many configurations (e.g., connection strings, environment variables for `apiservice`) are injected by the Aspire `AppHost`.
*   **Two-Database Split:** Remember that user data (Identity) and application data (shopping lists) are in separate contexts and databases.
*   **Secrets Management:** Emphasize that secrets are not hardcoded and should be managed externally (e.g., via `.env` and Aspire parameters).
*   **Data Flow:** Understand the flow from Minimal API Endpoint -> (potentially Service) -> Repository -> EF Core -> Database.
*   **Mapping:** Pay attention to mapping classes in `Mappers` folders.
*   **Modularity:** The project is well-divided into modules, which should aid in analyzing individual parts.
*   **Lack of a distinct Service Layer (Application Layer):** Much of the business logic resides directly in endpoints or repositories. For more complex operations, adding a service layer could be considered.
*   **Tests:** No test projects are present in the provided structure.